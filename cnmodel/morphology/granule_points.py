# compute tapered data from the Diwakar model
# print out the pt3dadd statements for each section
from neuron import h

n_hillock_sections:int = 5
n_axon_sections:int = 30
n_ais_sections:int = 5
n_axon_segments:int = 3
n_dendrites:int = 4
n_dendrite_sections:int = 4
n_soma_sections:int = 1

total_sections = (
    n_dendrite_sections * n_dendrites
    + n_hillock_sections
    + n_ais_sections
    + n_axon_sections
    + n_soma_sections
)
print(f"total sections needed: {total_sections:d}")


def lprint(s="", first=False):
    if first:
        mode = "w"
    else:
        mode = "a"
    with open("cnmodel/morphology/grc_stick_simple.hoc", mode) as f:
        f.write(f"{s}\n")


header = f"""
// Detailed model of Cerebellar Granular Cell model
// Multicompartmental model - cell template 
// Last updated 07-Jan-2009
// Model developer: Shyam Diwakar M.
// Developed at Egidio D'Angelo's Lab at Univ of Pavia
// Code contributors: Thierry Nieus, Sergio Solinas 
// Dept. of Gen. Physiology (Univ. of Pavia, Italy)
// School of biotech (Amrita University, India) 
// Email:shyam@unipv.it

/* Based on:
 Model published as [Diwakar et al, J.Neurophysiology] 
 Shyam Diwakar, Jacopo Magistretti, Mitchell Goldfarb, Giovanni Naldi, and Egidio D'Angelo.
 Axonal Na+ channels ensure fast spike activation and back-propagation in cerebellar granule cells, J Neurophysiol (December 10, 2008). 
 doi:10.1152/jn.90382.2008
 */ 
 
/* modified to just provide the cell structure directly, and NOT be a template.
Points for the cell were generated by grc_points.py
The instertion of channels and generation of multiple cells is handled in cnmodel
*/

objref soma
soma = new SectionList()
objref hillock
hillock = new SectionList()
objref ais
ais = new SectionList()
objref axon
axon = new SectionList()

objref primarydendrite
primarydendrite = new SectionList()
objref preclaw
preclaw = new SectionList()
objref dendriticclaw
dendriticclaw = new SectionList()

ndend={n_dendrites:d}
nsg={n_hillock_sections:d}
nais={n_ais_sections:d}
naxon={n_axon_sections:d}
create sections[{total_sections:d}]
"""
secbreak:str = "*" * 80

lprint(header, first=True)

lprint("// PBM Modified Auto-generated code for GRC cell")

L = 5.8
d = 5.8
x = 0.0
y = 0.0
z = 0.0  # starting z, but keep track of it
secpos:int = 0
lprint(f"access sections[{secpos:d}]")
lprint("soma.append()")
lprint(f"sections[{secpos:d}] {{")
for i in range(1):
    lprint(f"    pt3dadd(0, 0, {-z:.2f}, 5.8)")
    z += L
    lprint(f"    pt3dadd(0, 0, {-z:.2f}, 5.8)")
lprint("}\n")

lprint(f"\n//{secbreak:s}\n// Hillock")
# hillock keeps on the central axis
secpos += 1
for w1 in range(n_hillock_sections):
    lprint(f"access sections[{secpos}]")
    lprint("hillock.append()")
    diam = 2.3 - 0.5 * w1
    L = 0.5
    lprint(f"sections[{secpos}] {{")
    lprint(f"    pt3dadd(0, 0, {-z:.2f}, {diam:.2f})")
    lprint(f"    pt3dadd(0, 0, {-z-L:.2f}, {diam:.2f})")
    lprint("}")
    if secpos > 1:
        lprint(f"connect sections[{secpos:d}](0), sections[{secpos-1:d}](1)\n")
    else:
        lprint(f"connect sections[{secpos:d}](0), sections[{0:d}](1)\n")
    z += L
    secpos += 1

# AIS keeps on the central axis
for wais in range(n_ais_sections):
    lprint(f"access sections[{secpos}]")
    lprint("ais.append()")
    # diam = diam
    L = 2.0
    lprint(f"sections[{secpos}] {{")
    lprint(f"    pt3dadd(0, 0, {-z:.2f}, {diam:.2f})")
    lprint(f"    pt3dadd(0, 0, {-z-L:.2f}, {diam:.2f})")
    lprint("}")
    if secpos > 1:
        lprint(f"connect sections[{secpos:d}](0), sections[{secpos-1:d}](1)\n")
    else:
        lprint(f"connect sections[{secpos:d}](0), sections[{0:d}](1)\n")
    z += L
    secpos += 1


# axon segments keep on the central axis as well
lprint(f"\n//{secbreak:s}\n// Axon")
lprint(f"access sections[{secpos}]")

for secno in range(n_axon_sections):
    lprint("axon.append()")
    lprint(f"sections[{secpos}] {{")
    for w3 in range(n_axon_segments):
        diam = 0.3
        L = 20.0 / float(n_axon_segments)
        lprint(f"    pt3dadd(0, 0, {-z:.2f}, {diam:.2f})")
        z += L
    lprint("}")
    lprint(f"connect sections[{secpos:d}](0), sections[{secpos-1:d}](1)\n")
    secpos += 1


def map_dend_dirs(dnum, secnum, xd:float, yd:float, secpos:int):
    dend_dirs = {0: "N", 1: "E", 2: "S", 3: "W"}
    seclens = {0: 5, 1: 5, 2: 2.5, 3: 2.5}
    xdx:float = xd
    ydx:float = yd
    if dnum not in dend_dirs.keys():
        raise ValueError(f"Invalid dendrite number {dnum}")
    if secnum not in seclens.keys():
        raise ValueError(f"Invalid dendrite section number {secnum}")
    seclen = seclens[secnum]
    if dend_dirs[dnum] == "N":
        yd = ydx + seclen
    elif dend_dirs[dnum] == "E":
        xd = xdx + seclen
    elif dend_dirs[dnum] == "S":
        yd = ydx - seclen
    elif dend_dirs[dnum] == "W":
        xd = xdx - seclen
    print(
        f"dendrite:  {dnum:2d}, {secnum:2d}, xd0,yd0: {xd0:5.1f}, {yd0:5.1f}, {xd:5.1f}, {yd:5.1f}, {secpos:3d}"
    )
    return xd, yd


lprint(f"\n//{secbreak:s}\n// Dendrites")
dend_incr = {0: (0, 5), 1: (5, 0), 2: (0, -5), 3: (-5, 0)}
dend2_incr = {0: (0, 2.5), 1: (2.5, 0), 2: (0, -2.5), 3: (-2.5, 0)}

for dend_num in range(n_dendrites):  # for each of 4 dendrites
    lprint(f"\n// Dendrite {dend_num+1:d}")

    x = 0  # each dendrite comes from top of soma
    y = 0
    z = 0

    diam = 0.75

    xd0 = 0
    yd0 = 0
    for section_number in range(2):  # for each section in the primary dendrite
        lprint(f"access sections[{secpos}]")
        lprint("primarydendrite.append()")
        xd, yd = map_dend_dirs(dend_num, section_number, xd=xd0, yd=yd0, secpos=secpos)
        lprint(f"sections[{secpos}] {{")
        lprint(f"    pt3dadd({xd0:.2f}, {yd0:.2f}, {z:.2f}, {diam:.2f})")
        lprint(f"    pt3dadd({xd:.2f}, {yd:.2f}, {z:.2f}, {diam:.2f})")
        xd0 = xd
        yd0 = yd
        lprint("}")
        if section_number > 0:
            lprint(f"connect sections[{secpos:d}](0), sections[{secpos-1:d}](1)\n")
        else:
            lprint(f"connect sections[{secpos:d}](0), sections[{0:d}](0)\n")
        secpos += 1
    # add preclaw
    lprint(f"access sections[{secpos}]")
    lprint("preclaw.append()")
    xd, yd = map_dend_dirs(dend_num, 2, xd0, yd0, secpos)
    lprint(f"sections[{secpos}] {{")
    lprint(f"    pt3dadd({xd0:.2f}, {yd0:.2f}, {z:.2f}, {diam:.2f})")
    lprint(f"    pt3dadd({xd:.2f}, {yd:.2f}, {z:.2f}, {diam:.2f})")
    xd0 = xd  # save the endpoints
    yd0 = yd
    lprint("}")
    lprint(f"connect sections[{secpos:d}](0), sections[{secpos-1:d}](1)\n")
    secpos += 1
    # add claw
    lprint(f"access sections[{secpos}]")
    lprint("dendriticclaw.append()")
    lprint(f"sections[{secpos}] {{")
    xd, yd = map_dend_dirs(dend_num, 3, xd=xd0, yd=yd0, secpos=secpos)
    lprint(f"    pt3dadd({xd0:.2f}, {yd0:.2f}, {z:.2f}, {diam:.2f})")
    lprint(f"    pt3dadd({xd:.2f}, {yd:.2f}, {z:.2f}, {diam:.2f})")
    lprint("}")
    lprint(f"connect sections[{secpos:d}](0), sections[{secpos-1:d}](1)\n")
    secpos += 1
    lprint()

lprint("// End of cell")


# cell = ngauge.Neuron.from_swc("grc_stick_simple.swc")
h.load_file("cnmodel/morphology/grc_stick_simple.hoc")
h.topology()
# ps = h.PlotShape(True)  # False tells h.PlotShape not to use NEURON's gui
# ps.plot(mpl)
# mpl.show()
